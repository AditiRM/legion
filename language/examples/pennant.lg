-- Copyright 2014 Stanford University
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Inspired by https://github.com/losalamos/PENNANT

import "legion"

local c = legionlib.c

local sqrt = terralib.intrinsic("llvm.sqrt.f64", double -> double)

-- #####################################
-- ## Data Structures
-- #################

terra min(a : double, b : double) : double
  if a < b then
    return a
  else
    return b
  end
end

terra max(a : double, b : double) : double
  if a > b then
    return a
  else
    return b
  end
end

terra abs(a : double) : double
  if a < 0 then
    return -a
  else
    return a
  end
end

struct vec2 {
  x : double,
  y : double,
}

terra vec2.metamethods.__add(a : vec2, b : vec2) : vec2
  return vec2 { x = a.x + b.x, y = a.y + b.y }
end

terra vec2.metamethods.__sub(a : vec2, b : vec2) : vec2
  return vec2 { x = a.x - b.x, y = a.y - b.y }
end

terra vec2.metamethods.__mul(a : double, b : vec2) : vec2
  return vec2 { x = a * b.x, y = a * b.y }
end

terra vec2.metamethods.__mul(a : vec2, b : double) : vec2
  return vec2 { x = a.x * b, y = a.y * b }
end

terra dot(a : vec2, b : vec2) : double
  return a.x*b.x + a.y*b.y
end

terra cross(a : vec2, b : vec2) : double
  return a.x*b.y - a.y*b.x
end

terra length(a : vec2) : double
  return sqrt(dot(a, a))
end

terra rotateCCW(a : vec2) : vec2
  return vec2 { x = -a.y, y = a.x }
end

terra project(a : vec2, b : vec2)
  return a - b*dot(a, b)
end

struct config {
  -- Configuration variables.
  alfa : double,
  bcx_0 : double,
  bcx_1 : double,
  bcy_0 : double,
  bcy_1 : double,
  bcx_n : int,
  bcy_n : int,
  cfl : double,
  cflv : double,
  chunksize : int,
  cstop : int,
  dtfac : double,
  dtinit : double,
  dtmax : double,
  dtreport : double,
  einit : double,
  einitsub : double,
  gamma : double,
  meshscale : double,
  q1 : double,
  q2 : double,
  qgamma : double,
  rinit : double,
  rinitsub : double,
  ssmin : double,
  subregion_0 : double,
  subregion_1 : double,
  subregion_2 : double,
  subregion_3 : double,
  tstop : double,
  uinitradial : double,

  -- Mesh generator variables.
  meshtype : int,
  meshparams_0 : double,
  meshparams_1 : double,
  meshparams_2 : double,
  meshparams_3 : double,
  meshparams_n : int,
  nzx : int,
  nzy : int,
  numpcx : int,
  numpcy : int,
  lenx : double,
  leny : double,

  -- Mesh variables.
  nz : int,
  np : int,
  ns : int,
  maxznump : int,

  -- Command-line parameters.
  npieces : int,
  use_foreign : bool,
}

fspace zone {
  znump :  int,          -- number of points in zone
  zxp :    vec2,         -- zone center coordinates, middle of cycle
  zx :     vec2,         -- zone center coordinates, end of cycle
  zareap : double,       -- zone area, middle of cycle
  zarea :  double,       -- zone area, end of cycle
  zvol0 :  double,       -- zone volume, start of cycle
  zvolp :  double,       -- zone volume, middle of cycle
  zvol :   double,       -- zone volume, end of cycle
  zdl :    double,       -- zone characteristic length
  zm :     double,       -- zone mass
  zrp :    double,       -- zone density, middle of cycle
  zr :     double,       -- zone density, end of cycle
  ze :     double,       -- zone specific energy
  zetot :  double,       -- zone total energy
  zw :     double,       -- zone work
  zwrate : double,       -- zone work rate
  zp :     double,       -- zone pressure
  zss :    double,       -- zone sound speed
  zdu :    double,       -- zone delta velocity (???)

  -- Temporaries for QCS
  zuc :    vec2,         -- zone center velocity
  z0tmp :  double,       -- temporary for qcs_vel_diff
}

fspace point {
  px0 : vec2,            -- point coordinates, start of cycle
  pxp : vec2,            -- point coordinates, middle of cycle
  px :  vec2,            -- point coordinates, end of cycle
  pu0 : vec2,            -- point velocity, start of cycle
  pu :  vec2,            -- point velocity, end of cycle
  pap : vec2,            -- point acceleration, middle of cycle
  pf :  vec2,            -- point force
  pmaswt : double,       -- point mass

  -- Used for computing boundary conditions
  has_bcx_0 : bool,
  has_bcx_1 : bool,
  has_bcy_0 : bool,
  has_bcy_1 : bool,
}

fspace side(rz : region(zone),
            rpp : region(point),
            rpg : region(point),
            rs : region(side(rz, rpp, rpg, rs))) {
  mapsz :  ptr(zone, rz),                      -- maps: side -> zone
  mapsp1 : ptr(point, rpp), --, rpg),          -- maps: side -> points 1 and 2
  mapsp2 : ptr(point, rpp), --, rpg),          -- FIXME
  mapss3 : ptr(side(rz, rpp, rpg, rs), rs),    -- maps: side -> previous side
  mapss4 : ptr(side(rz, rpp, rpg, rs), rs),    -- maps: side -> next side

  sareap : double,       -- side area, middle of cycle
  sarea :  double,       -- side area, end of cycle
  svolp :  double,       -- side volume, middle of cycle
  svol :   double,       -- side volume, end of cycle
  ssurfp : vec2,         -- side surface vector, middle of cycle
  smf :    double,       -- side mass fraction
  sfp :    vec2,         -- side force, pgas
  sft :    vec2,         -- side force, tts
  sfq :    vec2,         -- side force, qcs

  -- In addition to storing their own state, sides also store the
  -- state of edges and corners. This can be done because there is a
  -- 1-1 correspondence between sides and edges/corners. Technically,
  -- edges can be shared between zones, but the computations on edges
  -- are minimal, and are not actually used for sharing information,
  -- so duplicating computations on edges is inexpensive.

  -- Edge variables
  exp :    vec2,         -- edge center coordinates, middle of cycle
  ex :     vec2,         -- edge center coordinates, end of cycle
  elen :   double,       -- edge length, end of cycle

  -- Corner variables (temporaries for QCS)
  carea :  double,       -- corner area
  cevol :  double,       -- corner evol
  cdu :    double,       -- corner delta velocity
  cdiv :   double,       -- ??????????
  ccos :   double,       -- corner cosine
  cqe1 :   vec2,         -- ??????????
  cqe2 :   vec2,         -- ??????????
}

fspace mesh(rz : region(zone),
            rp : region(point),
            rs : region(side(wild, wild, wild, wild))) {
  rzp : region(zone),
  rpp : region(point),
  rpg : region(point),
  rps : region(point),
  rsp : region(side(rzp, rpp, rpg, rsp)),

  -- Coloring
  mcolor : int,          -- mesh piece color

  -- Index bounds for C++ kernels
  zstart : int,          -- zone start index
  zend : int,            -- zone end index (exclusive)
  sstart : int,          -- side start index
  send : int,            -- side end index (exclusive)
} where
  rzp <= rz, rpp <= rp, rpg <= rp, rps <= rp,
  -- rpp * rpg, rpp * rps, -- FIXME
  rsp <= rs

-- #####################################
-- ## Initialization
-- #################

-- Hack: This exists to make the compiler recompute the bitmasks for
-- each pointer. This needs to happen here (rather than at
-- initialization time) because we subverted the type system in the
-- construction of the mesh pieces.
task init_pointers(rz : region(zone), rpp : region(point), rpg : region(point),
                   rs : region(side(rz, rpp, rpg, rs))),
  reads(rs.{mapsp1, mapsp2}),
  writes(rs.{mapsp1, mapsp2})

  for s in rs do
    s.mapsp1 = s.mapsp1 -- downregion<rpp, rpg>(s->mapsp1) -- FIXME
    s.mapsp2 = s.mapsp2 -- downregion<rpp, rpg>(s->mapsp2)
  end
end
init_pointers:compile()

task init_mesh_zones(rz : region(zone)),
  writes(rz.{zx, zarea, zvol})
  for z in rz do
    z.zx = vec2 {x = 0.0, y = 0.0}
    z.zarea = 0.0
    z.zvol = 0.0
  end
end
init_mesh_zones:compile()

-- Call calc_centers_full.
-- Call calc_volumes_full.

task init_side_fracs(rz : region(zone), rpp : region(point), rpg : region(point),
                     rs : region(side(rz, rpp, rpg, rs)))
  , reads(rz.zarea, rs.{mapsz, sarea})
  , writes(rs.smf)
  for s in rs do
    var z = s.mapsz

    s.smf = s.sarea / z.zarea
  end
end
init_side_fracs:compile()

task init_hydro(rz : region(zone), rinit : double, einit : double,
                rinitsub : double, einitsub : double,
                subregion_x0 : double, subregion_x1 : double,
                subregion_y0 : double, subregion_y1 : double)
  , reads(rz.{zx, zvol})
  , writes(rz.{zr, ze, zwrate, zm, zetot})
  for z in rz do
    var zr = rinit
    var ze = einit

    var eps = 1e-12
    if z.zx.x > subregion_x0 - eps and
      z.zx.x < subregion_x1 + eps and
      z.zx.y > subregion_y0 - eps and
      z.zx.y < subregion_y1 + eps
    then
      zr = rinitsub
      ze = einitsub
    end

    var zm = zr * z.zvol

    z.zr = zr
    z.ze = ze
    z.zwrate = 0.0
    z.zm = zm
    z.zetot = ze * zm
  end
end
init_hydro:compile()

task init_radial_velocity(rp : region(point), vel : double)
  , reads(rp.px)
  , writes(rp.pu)
  for p in rp do
    if vel == 0.0 then
      p.pu = {x = 0.0, y = 0.0}
    else
      var pmag = length(p.px)
      p.pu = (vel / pmag)*p.px
    end
  end
end
init_radial_velocity:compile()

-- #####################################
-- ## Main simulation loop
-- #################

-- Save off point variable values from previous cycle.
task init_step_points(rp : region(point))
  , reads(rp.{px, pu})
  , writes(rp.{px0, pu0, pmaswt, pf})
  for p in rp do
    -- Copy state variables from previous time step.
    p.px0 = p.px
    p.pu0 = p.pu

    -- Initialize fields used in reductions.
    p.pmaswt = 0.0
    p.pf = {x = 0.0, y = 0.0}
  end
end
init_step_points:compile()

--
-- 1. Advance mesh to center of time step.
--
task adv_pos_half(rp : region(point), dt : double)
  , reads(rp.{px0, pu0})
  , writes(rp.pxp)
  var dth = 0.5 * dt

  for p in rp do
    p.pxp = p.px0 + dth*p.pu0
  end
end
adv_pos_half:compile()

-- Save off zone variable value from previous cycle.
task init_step_zones(rz : region(zone),
                     zstart : int, zend : int, use_foreign : bool)
  , reads(rz.zvol)
  , writes(rz.{zxp, zx, zareap, zarea, zvol0, zvolp, zvol, zdl, zw, zuc})
  if use_foreign then
    -- foreign_init_step_zones(zstart, zend, rz)
  else
    for z in rz do
      -- Copy state variables from previous time step.
      z.zvol0 = z.zvol

      -- Initialize fields used in reductions.
      z.zxp = vec2 {x = 0.0, y = 0.0}
      z.zx = vec2 {x = 0.0, y = 0.0}
      z.zareap = 0.0
      z.zarea = 0.0
      z.zvolp = 0.0
      z.zvol = 0.0
      z.zdl = 1e99
      z.zw = 0.0
      z.zuc = vec2 {x = 0.0, y = 0.0}
    end
  end
end
init_step_zones:compile()

--
-- 1a. Compute new mesh geometry.
--

-- Compute centers of zones and edges.
task calc_centers(rz : region(zone), rpp : region(point), rpg : region(point),
                  rs : region(side(rz, rpp, rpg, rs)),
                  sstart : int, send : int, use_foreign : bool)
  , reads(rz.{znump, zxp}, rpp.pxp, rpg.pxp, rs.{mapsz, mapsp1, mapsp2})
  , writes(rz.zxp, rs.exp)
  if use_foreign then
    -- foreign_calc_centers(sstart, send, rz, rpp, rpg, rs)
  else
    for s in rs do
      var z = s.mapsz
      var p1 = s.mapsp1
      var p2 = s.mapsp2
      var e = s

      e.exp = 0.5*(p1.pxp + p2.pxp)

      z.zxp += (1/double(z.znump)) * p1.pxp
    end
  end
end
calc_centers:compile()

-- Compute volumes of zones and sides.
task calc_volumes(rz : region(zone), rpp : region(point), rpg : region(point),
                  rs : region(side(rz, rpp, rpg, rs)),
                  sstart : int, send : int, use_foreign : bool)
  , reads(rz.{zxp, zareap, zvolp}, rpp.pxp, rpg.pxp, rs.{mapsz, mapsp1, mapsp2})
  , writes(rz.{zareap, zvolp}, rs.{sareap, svolp})
  if use_foreign then
    -- foreign_calc_volumes(sstart, send, rz, rpp, rpg, rs)
  else
    for s in rs do
      var z = s.mapsz
      var p1 = s.mapsp1
      var p2 = s.mapsp2

      var sa = 0.5 * cross(p2.pxp - p1.pxp, z.zxp - p1.pxp)
      var sv = (1.0 / 3.0) * sa * (p1.pxp.x + p2.pxp.x + z.zxp.x)
      s.sareap = sa
      s.svolp = sv

      z.zareap += sa
      z.zvolp += sv

      assert(sv > 0.0)
    end
  end
end
calc_volumes:compile()

-- Compute surface vectors of sides.
task calc_surface_vecs(rz : region(zone), rpp : region(point), rpg : region(point),
                       rs : region(side(rz, rpp, rpg, rs)),
                       sstart : int, send : int, use_foreign : bool)
  , reads(rz.zxp, rs.{mapsz, exp})
  , writes(rs.ssurfp)
  if use_foreign then
    -- foreign_calc_surface_vecs(sstart, send, rz, rs)
  else
    for s in rs do
      var z = s.mapsz
      var e = s

      s.ssurfp = rotateCCW(e.exp - z.zxp)
    end
  end
end
calc_surface_vecs:compile()

-- Compute edge lengths.
task calc_edge_len(rz : region(zone), rpp : region(point), rpg : region(point),
                   rs : region(side(rz, rpp, rpg, rs)),
                   sstart : int, send : int, use_foreign : bool)
  , reads(rpp.pxp, rpg.pxp, rs.{mapsp1, mapsp2})
  , writes(rs.elen)
  if use_foreign then
    -- foreign_calc_edge_len(sstart, send, rpp, rpg, rs)
  else
    for s in rs do
      var p1 = s.mapsp1
      var p2 = s.mapsp2
      var e = s

      e.elen = length(p2.pxp - p1.pxp)
    end
  end
end
calc_edge_len:compile()

-- Compute zone characteristic lengths.
task calc_char_len(rz : region(zone), rpp : region(point), rpg : region(point),
                   rs : region(side(rz, rpp, rpg, rs)),
                   sstart : int, send : int, use_foreign : bool)
  , reads(rz.{znump, zdl}, rs.{mapsz, sareap, elen})
  , writes(rz.zdl)
  if use_foreign then
    -- foreign_calc_char_len(sstart, send, rz, rs)
  else
    for s in rs do
      var z = s.mapsz
      var e = s

      var area = s.sareap
      var base = e.elen
      var fac = 0.0
      if z.znump == 3 then
        fac = 3.0
      else
        fac = 4.0
      end
      var sdl = fac * area / base
      z.zdl = min(z.zdl, sdl)
    end
  end
end
calc_char_len:compile()

--
-- 2. Compute point masses.
--

-- Compute zone densities.
task calc_rho_half(rz : region(zone),
                   zstart : int, zend : int, use_foreign : bool)
  , reads(rz.{zvolp, zm})
  , writes(rz.zrp)
  if use_foreign then
    -- foreign_calc_rho_half(zstart, zend, rz)
  else
    for z in rz do
      z.zrp = z.zm / z.zvolp
    end
  end
end
calc_rho_half:compile()

-- Reduce masses into points.
task sum_point_mass(rz : region(zone), rpp : region(point), rpg : region(point),
                    rs : region(side(rz, rpp, rpg, rs)),
                    sstart : int, send : int, use_foreign : bool)
  , reads(rz.{zareap, zrp}, rpp.pmaswt, rs.{mapsz, mapsp1, mapss3, smf})
  , writes(rpp.pmaswt)
  , reduces +(rpg.pmaswt)
  if use_foreign then
    -- foreign_sum_point_mass(sstart, send, rz, rpp, rpg, rs)
  else
    for s in rs do
      var z = s.mapsz
      var p1 = s.mapsp1
      var s3 = s.mapss3

      var m = z.zrp * z.zareap * 0.5 * (s.smf + s3.smf)
      p1.pmaswt += m
    end
  end
end
sum_point_mass:compile()

--
-- 3. Compute material state (half-advanced).
--

task calc_state_at_half(rz : region(zone),
                        gamma : double, ssmin : double, dt : double,
                        zstart : int, zend : int, use_foreign : bool)
  , reads(rz.{zvol0, zvolp, zm, zr, ze, zwrate})
  , writes(rz.{zp, zss})
  if use_foreign then
    -- foreign_calc_state_at_half(gamma, ssmin, dt, zstart, zend, rz)
  else
    var gm1 = gamma - 1.0
    var ss2 = max(ssmin * ssmin, 1e-99)
    var dth = 0.5 * dt

    for z in rz do
      var rx = z.zr
      var ex = max(z.ze, 0.0)
      var px = gm1 * rx * ex
      var prex = gm1 * ex
      var perx = gm1 * rx
      var csqd = max(ss2, prex + perx * px / (rx * rx))
      var z0per = perx
      var zss = sqrt(csqd)
      z.zss = zss

      var zminv = 1.0 / z.zm
      var dv = (z.zvolp - z.zvol0) * zminv
      var bulk = z.zr * zss * zss
      var denom = 1.0 + 0.5 * z0per * dv
      var src = z.zwrate * dth * zminv
      z.zp = px + (z0per * src - z.zr * bulk * dv) / denom
    end
  end
end
calc_state_at_half:compile()

--
-- 4. Compute forces.
--

-- Compute PolyGas forces.
task calc_force_pgas(rz : region(zone), rpp : region(point), rpg : region(point),
                     rs : region(side(rz, rpp, rpg, rs)),
                     sstart : int, send : int, use_foreign : bool)
  , reads(rz.zp, rs.{mapsz, ssurfp})
  , writes(rs.sfp)
  if use_foreign then
    -- foreign_calc_force_pgas(sstart, send, rz, rs)
  else
    for s in rs do
      var z = s.mapsz
      var sfx = (-z.zp)*s.ssurfp
      s.sfp = sfx
    end
  end
end
calc_force_pgas:compile()

-- Compute TTS forces.
task calc_force_tts(rz : region(zone), rpp : region(point), rpg : region(point),
                    rs : region(side(rz, rpp, rpg, rs)),
                    alfa : double, ssmin : double,
                    sstart : int, send : int, use_foreign : bool)
  , reads(rz.{zareap, zrp, zss}, rs.{mapsz, sareap, smf, ssurfp})
  , writes(rs.sft)
  if use_foreign then
    -- foreign_calc_force_tts(alfa, ssmin, sstart, send, rz, rs)
  else
    for s in rs do
      var z = s.mapsz

      var svfacinv = z.zareap / s.sareap
      var srho = z.zrp * s.smf * svfacinv
      var sstmp = max(z.zss, ssmin)
      sstmp = alfa * sstmp * sstmp
      var sdp = sstmp * (srho - z.zrp)
      var sqq = (-sdp)*s.ssurfp
      s.sft = sqq
    end
  end
end
calc_force_tts:compile()

task qcs_zone_center_velocity(rz : region(zone), rpp : region(point), rpg : region(point),
                              rs : region(side(rz, rpp, rpg, rs)),
                              sstart : int, send : int, use_foreign : bool)
  , reads(rz.{znump, zuc}, rpp.pu, rpg.pu, rs.{mapsz, mapsp1})
  , writes(rz.zuc)
  if use_foreign then
    -- foreign_qcs_zone_center_velocity(sstart, send, rz, rpp, rpg, rs)
  else
    for s in rs do
      var z = s.mapsz
      var p1 = s.mapsp1

      var zuc = (1.0 / double(z.znump))*p1.pu
      z.zuc.x += zuc.x
      z.zuc.y += zuc.y
    end
  end
end
qcs_zone_center_velocity:compile()

task qcs_corner_divergence(rz : region(zone), rpp : region(point), rpg : region(point),
                           rs : region(side(rz, rpp, rpg, rs)),
                           sstart : int, send : int, use_foreign : bool)
  , reads(rz.{zxp, zuc}, rpp.{pxp, pu}, rpg.{pxp, pu},
          rs.{mapsz, mapsp1, mapsp2, mapss3, exp, elen})
  , writes(rs.{carea, ccos, cdiv, cevol, cdu})
  if use_foreign then
    -- foreign_qcs_corner_divergence(sstart, send, rz, rpp, rpg, rs)
  else
    for s2 in rs do
      var c = s2
      var s = s2.mapss3
      var z = s.mapsz
      var p = s.mapsp2
      var p1 = s.mapsp1
      var p2 = s2.mapsp2
      var e1 = s
      var e2 = s2

      -- velocities and positions
      -- point p
      var up0 = p.pu
      var xp0 = p.pxp
      -- edge e2
      var up1 = 0.5*(p.pu + p2.pu)
      var xp1 = e2.exp
      -- zone center z
      var up2 = z.zuc
      var xp2 = z.zxp
      -- edge e1
      var up3 = 0.5*(p1.pu + p.pu)
      var xp3 = e1.exp

      -- compute 2d cartesian volume of corner
      var cvolume = 0.5 * cross(xp2 - xp0, xp3 - xp1)
      c.carea = cvolume

      -- compute cosine angle
      var v1 = xp3 - xp0
      var v2 = xp1 - xp0
      var de1 = e1.elen
      var de2 = e2.elen
      var minelen = min(de1, de2)
      if minelen < 1e-12 then
        c.ccos = 0.0
      else
        c.ccos = 4.0 * dot(v1, v2) / (de1 * de2)
      end

      -- compute divergence of corner
      var cdiv = (cross(up2 - up0, xp3 - xp1) -
                  cross(up3 - up1, xp2 - xp0)) / (2.0 * cvolume)
      c.cdiv = cdiv

      -- compute evolution factor
      var dxx1 = 0.5*(((xp1 + xp2) - xp0) - xp3)
      var dxx2 = 0.5*(((xp2 + xp3) - xp0) - xp1)
      var dx1 = length(dxx1)
      var dx2 = length(dxx2)

      -- average corner-centered velocity
      var duav = 0.25*(((up0 + up1) + up2) + up3)

      var test1 = abs(dot(dxx1, duav) * dx2)
      var test2 = abs(dot(dxx2, duav) * dx1)
      var num = 0.0
      var den = 0.0
      if test1 > test2 then
        num = dx1
        den = dx2
      else
        num = dx2
        den = dx1
      end
      var r = num / den
      var evol = min(sqrt(4.0 * cvolume * r), 2.0 * minelen)

      -- compute delta velocity
      var dv1 = length(((up1 + up2) - up0) - up3)
      var dv2 = length(((up2 + up3) - up0) - up1)
      var du = max(dv1, dv2)

      if cdiv < 0.0 then
        c.cevol = evol
        c.cdu = du
      else
        c.cevol = 0.0
        c.cdu = 0.0
      end
    end
  end
end
qcs_corner_divergence:compile()

task qcs_qcn_force(rz : region(zone), rpp : region(point), rpg : region(point),
                   rs : region(side(rz, rpp, rpg, rs)),
                   gamma : double, q1 : double, q2 : double,
                   sstart : int, send : int, use_foreign : bool)
  , reads(rz.{zrp, zss}, rpp.pu, rpg.pu,
          rs.{mapsz, mapsp1, mapsp2, mapss3, elen, cdiv, cdu, cevol})
  , writes(rs.{cqe1, cqe2})
  if use_foreign then
    -- foreign_qcs_qcn_force(gamma, q1, q2, sstart, send, rz, rpp, rpg, rs)
  else
    var gammap1 = gamma + 1.0

    for s4 in rs do
      var c = s4
      var z = c.mapsz

      var ztmp2 = q2 * 0.25 * gammap1 * c.cdu
      var ztmp1 = q1 * z.zss
      var zkur = ztmp2 + sqrt(ztmp2 * ztmp2 + ztmp1 * ztmp1)
      var rmu = zkur * z.zrp * c.cevol
      if c.cdiv > 0.0 then
        rmu = 0.0
      end

      var s = c.mapss3
      var p = s.mapsp2
      var p1 = s.mapsp1
      var e1 = s
      var p2 = s4.mapsp2
      var e2 = s4

      c.cqe1 = rmu / e1.elen*(p.pu - p1.pu)
      c.cqe2 = rmu / e2.elen*(p2.pu - p.pu)
    end
  end
end
qcs_qcn_force:compile()

task qcs_force(rz : region(zone), rpp : region(point), rpg : region(point),
               rs : region(side(rz, rpp, rpg, rs)),
               sstart : int, send : int, use_foreign : bool)
  , reads(rs.{mapss4, elen, carea, ccos, cqe1, cqe2})
  , writes(rs.sfq)
  if use_foreign then
    -- foreign_qcs_force(sstart, send, rs)
  else
    for s in rs do
      var c1 = s
      var c2 = s.mapss4
      var e = s
      var el = e.elen

      var c1sin2 = 1.0 - c1.ccos * c1.ccos
      var c1w = 0.0
      var c1cos = 0.0
      if c1sin2 >= 1e-4 then
        c1w = c1.carea / c1sin2
        c1cos = c1.ccos
      end

      var c2sin2 = 1.0 - c2.ccos * c2.ccos
      var c2w = 0.0
      var c2cos = 0.0
      if c2sin2 >= 1e-4 then
        c2w = c2.carea / c2sin2
        c2cos = c2.ccos
      end

      s.sfq = (1.0 / el)*(c1w*(c1.cqe2 + c1cos*c1.cqe1) +
                            c2w*(c2.cqe1 + c2cos*c2.cqe2))
    end
  end
end
qcs_force:compile()

task qcs_vel_diff(rz : region(zone), rpp : region(point), rpg : region(point),
                  rs : region(side(rz, rpp, rpg, rs)),
                  q1 : double, q2 : double,
                  zstart : int, zend : int, sstart : int, send : int,
                  use_foreign : bool)
  , reads(rz.{zss, z0tmp}, rpp.{pxp, pu}, rpg.{pxp, pu},
          rs.{mapsp1, mapsp2, mapsz, elen})
  , writes(rz.{zdu, z0tmp})
  for z in rz do
    z.z0tmp = 0.0
  end

  for s in rs do
    var p1 = s.mapsp1
    var p2 = s.mapsp2
    var z = s.mapsz
    var e = s

    var dx = p2.pxp - p1.pxp
    var du = p2.pu - p1.pu
    var lenx = e.elen
    var dux = dot(du, dx)
    if lenx > 0.0 then
      dux = abs(dux) / lenx
    else
      dux = 0.0
    end
    z.z0tmp = max(z.z0tmp, dux)
  end

  for z in rz do
    z.zdu = q1 * z.zss + 2.0 * q2 * z.z0tmp
  end
end
qcs_vel_diff:compile()

-- Compute QCS forces.
task calc_force_qcs(rz : region(zone), rpp : region(point), rpg : region(point),
                    rs : region(side(rz, rpp, rpg, rs)),
                    gamma : double, q1 : double, q2 : double,
                    zstart : int, zend : int,
                    sstart : int, send : int,
                    use_foreign : bool)
  , reads(rz.{zxp, zrp, znump, zss, zuc, zdu, z0tmp},
          rpp.{pxp, pu}, rpg.{pxp, pu},
          rs.{mapsz, mapsp1, mapsp2, mapss3, mapss4, exp, elen, carea, ccos, cevol, cdiv, cdu, cqe1, cqe2})
  , writes(rz.{zuc, zdu, z0tmp},
           rs.{sfq, carea, cdiv, cevol, ccos, cdu, cqe1, cqe2})
  qcs_zone_center_velocity(rz, rpp, rpg, rs, sstart, send, use_foreign)
  qcs_corner_divergence(rz, rpp, rpg, rs, sstart, send, use_foreign)
  qcs_qcn_force(rz, rpp, rpg, rs, gamma, q1, q2, sstart, send, use_foreign)
  qcs_force(rz, rpp, rpg, rs, sstart, send, use_foreign)
  qcs_vel_diff(rz, rpp, rpg, rs, q1, q2, zstart, zend, sstart, send, use_foreign)
end
calc_force_qcs:compile()

-- Reduce forces into points.
task sum_point_force(rz : region(zone), rpp : region(point), rpg : region(point),
                     rs : region(side(rz, rpp, rpg, rs)),
                     sstart : int, send : int, use_foreign : bool)
  , reads(rpp.pf, rs.{mapsz, mapsp1, mapss3, sfp, sfq, sft})
  , writes(rpp.pf)
  , reduces +(rpg.pf.{x, y})
  if use_foreign then
    -- foreign_sum_point_force(sstart, send, rpp, rpg, rs)
  else
    for s in rs do
      var z = s.mapsz
      var p1 = s.mapsp1
      var s3 = s.mapss3

      var f = (s.sfp + (s.sfq + s.sft)) - (s3.sfp + (s3.sfq + s3.sft))
      p1.pf.x += f.x
      p1.pf.y += f.y
    end
  end
end
sum_point_force:compile()

--
-- 4a. Apply boundary conditions.
--

task apply_boundary_conditions(rp : region(point))
  , reads(rp.{pu0, pf, has_bcx_0, has_bcx_1, has_bcy_0, has_bcy_1})
  , writes(rp.{pu0, pf})
  var vfixx = {x = 1.0, y = 0.0}
  var vfixy = {x = 0.0, y = 1.0}
  for p in rp do
    if p.has_bcx_0 or p.has_bcx_1 then
      p.pu0 = project(p.pu0, vfixx)
      p.pf = project(p.pf, vfixx)
    end
    if p.has_bcy_0 or p.has_bcy_1 then
      p.pu0 = project(p.pu0, vfixy)
      p.pf = project(p.pf, vfixy)
    end
  end
end
apply_boundary_conditions:compile()

--
-- 5. Compute accelerations.
--

task calc_accel(rp : region(point))
  , reads(rp.{pf, pmaswt})
  , writes(rp.pap)
  var fuzz = 1e-99
  for p in rp do
    p.pap = (1.0 / max(p.pmaswt, fuzz))*(p.pf)
  end
end
calc_accel:compile()

--
-- 6. Advance mesh to end of time step.
--

task adv_pos_full(rp : region(point), dt : double)
  , reads(rp.{px0, pu0, pap})
  , writes(rp.{px, pu})
  for p in rp do
    var pu = p.pu0 + dt*(p.pap)
    p.pu = pu
    p.px = p.px0 + (0.5 * dt)*(pu + p.pu0)
  end
end
adv_pos_full:compile()

--
-- 6a. Compute new mesh geometry.
--

-- FIXME: This is a duplicate of calc_centers but with different
-- code. Struct slicing ought to make it possible to use the same code
-- in both cases.
task calc_centers_full(rz : region(zone), rpp : region(point), rpg : region(point),
                       rs : region(side(rz, rpp, rpg, rs)),
                       sstart : int, send : int, use_foreign : bool)
  , reads(rz.{znump, zx}, rpp.px, rpg.px, rs.{mapsz, mapsp1, mapsp2})
  , writes(rz.zx, rs.ex)
  if use_foreign then
    -- foreign_calc_centers_full(sstart, send, rz, rpp, rpg, rs)
  else
    for s in rs do
      var z = s.mapsz
      var p1 = s.mapsp1
      var p2 = s.mapsp2
      var e = s

      e.ex = 0.5*(p1.px + p2.px)

      z.zx += (1.0 / double(z.znump))*p1.px
    end
  end
end
calc_centers_full:compile()

-- FIXME: This is a duplicate of calc_volumes but with different
-- code. Struct slicing ought to make it possible to use the same code
-- in both cases.
task calc_volumes_full(rz : region(zone), rpp : region(point), rpg : region(point),
                       rs : region(side(rz, rpp, rpg, rs)),
                       sstart : int, send : int, use_foreign : bool)
  , reads(rz.{zx, zarea, zvol}, rpp.px, rpg.px, rs.{mapsz, mapsp1, mapsp2})
  , writes(rz.{zarea, zvol}, rs.{sarea, svol})
  if use_foreign then
    -- foreign_calc_volumes_full(sstart, send, rz, rpp, rpg, rs)
  else
    for s in rs do
      var z = s.mapsz
      var p1 = s.mapsp1
      var p2 = s.mapsp2

      var sa = 0.5 * cross(p2.px - p1.px, z.zx - p1.px)
      var sv = (1.0 / 3.0) * sa * (p1.px.x + p2.px.x + z.zx.x)
      s.sarea = sa
      s.svol = sv

      z.zarea += sa
      z.zvol += sv

      assert(sv > 0.0)
    end
  end
end
calc_volumes_full:compile()

--
-- 7. Compute work
--

task calc_work(rz : region(zone), rpp : region(point), rpg : region(point),
               rs : region(side(rz, rpp, rpg, rs)),
               dt : double,
               sstart : int, send : int, use_foreign : bool)
  , reads(rz.{zw, zetot}, rpp.{pxp, pu0, pu}, rpg.{pxp, pu0, pu},
          rs.{mapsz, mapsp1, mapsp2, sfp, sfq})
  , writes(rz.{zw, zetot})
  if use_foreign then
    -- foreign_calc_work(dt, sstart, send, rz, rpp, rpg, rs)
  else
    for s in rs do
      var z = s.mapsz
      var p1 = s.mapsp1
      var p2 = s.mapsp2

      var sftot = s.sfp + s.sfq
      var sd1 = dot(sftot, p1.pu0 + p1.pu)
      var sd2 = dot(-1.0*sftot, p2.pu0 + p2.pu)
      var dwork = -0.5 * dt * (sd1 * p1.pxp.x + sd2 * p2.pxp.x)

      z.zetot += dwork
      z.zw += dwork
    end
  end
end
calc_work:compile()

--
-- 7a. Compute work rate.
--

task calc_work_rate(rz : region(zone), dt : double)
  , reads(rz.{zvol0, zvol, zw, zp})
  , writes(rz.zwrate)
  var dtiny = 1.0 / dt

  for z in rz do
    var dvol = z.zvol - z.zvol0
    z.zwrate = (z.zw + z.zp * dvol) * dtiny
  end
end
calc_work_rate:compile()

--
-- 8. Update state variables.
--

task calc_energy(rz : region(zone))
  , reads(rz.{zm, zetot})
  , writes(rz.ze)
  var fuzz = 1e-99

  for z in rz do
    z.ze = z.zetot / (z.zm + fuzz)
  end
end
calc_energy:compile()

task calc_rho_full(rz : region(zone))
  , reads(rz.{zvol, zm})
  , writes(rz.zr)
  for z in rz do
    z.zr = z.zm / z.zvol
  end
end
calc_rho_full:compile()

--
-- 9. Compute timstep for next cycle.
--

task calc_dt_courant(rz : region(zone), dtmax : double, cfl : double)
  : double
  , reads(rz.{zdl, zss, zdu})
  var fuzz = 1e-99
  var dtnew = dtmax
  for z in rz do
    var cdu = max(z.zdu, max(z.zss, fuzz))
    var zdthyd = z.zdl * cfl / cdu

    dtnew = min(dtnew, zdthyd)
  end

  return dtnew
end
calc_dt_courant:compile()

task calc_dt_volume(rz : region(zone), dtlast : double, cflv : double)
  : double
  , reads(rz.{zvol0, zvol})
  var dvovmax = 1e-99
  for z in rz do
    var zdvov = abs((z.zvol - z.zvol0) / z.zvol0)
    dvovmax = max(zdvov, dvovmax)
  end
  return dtlast * cflv / dvovmax
end
calc_dt_volume:compile()

task calc_dt_hydro(rz : region(zone), dtlast : double, dtmax : double, cfl : double, cflv : double)
  : double
  , reads(rz.{zdl, zvol0, zvol, zss, zdu})
  var dthydro = dtmax

  dthydro = min(dthydro,
                 min(calc_dt_courant(rz, dtmax, cfl),
                      calc_dt_volume(rz, dtlast, cflv)))

  return dthydro
end
calc_dt_hydro:compile()

terra calc_global_dt(dt : double, dtfac : double, dtinit : double,
                     dtmax : double, dthydro : double,
                     time : double, tstop : double, cycle : int) : double
  var dtlast = dt

  dt = dtmax

  if cycle == 0 then
    dt = min(dt, dtinit)
  else
    var dtrecover = dtfac * dtlast
    dt = min(dt, dtrecover)
  end

  dt = min(dt, tstop - time)
  dt = min(dt, dthydro)

  return dt
end

task initialize(rz_all : region(zone), rp_all : region(point),
                rs_all : region(side(wild, wild, wild, wild)),
                rm_all : region(mesh(rz_all, rp_all, rs_all)),
                conf : config)
  , reads(rz_all, rp_all, rs_all, rm_all)
  , writes(rz_all, rp_all, rs_all, rm_all)
  var einit = conf.einit
  var einitsub = conf.einitsub
  var rinit = conf.rinit
  var rinitsub = conf.rinitsub
  var subregion_0 = conf.subregion_0
  var subregion_1 = conf.subregion_1
  var subregion_2 = conf.subregion_2
  var subregion_3 = conf.subregion_3
  var uinitradial = conf.uinitradial

  var use_foreign = conf.use_foreign

  for m in rm_all do
    var {rz = rzp, rpp, rpg, rps, rs = rsp} = @m
    init_pointers(rz, rpp, rpg, rs)
  end

  for m in rm_all do
    var {rz = rzp, rpp, rpg, rps, rs = rsp} = @m
    init_mesh_zones(rz)
  end

  for m in rm_all do
    var {rz = rzp, rpp, rpg, rps, rs = rsp} = @m
    calc_centers_full(rz, rpp, rpg, rs, m.sstart, m.send, use_foreign)
  end

  for m in rm_all do
    var {rz = rzp, rpp, rpg, rps, rs = rsp} = @m
    calc_volumes_full(rz, rpp, rpg, rs, m.sstart, m.send, use_foreign)
  end

  for m in rm_all do
    var {rz = rzp, rpp, rpg, rps, rs = rsp} = @m
    init_side_fracs(rz, rpp, rpg, rs)
  end

  for m in rm_all do
    var {rz = rzp, rpp, rpg, rps, rs = rsp} = @m
    init_hydro(rz, rinit, einit, rinitsub, einitsub, subregion_0, subregion_1, subregion_2, subregion_3)
  end

  for m in rm_all do
    var {rz = rzp, rpp, rpg, rps, rs = rsp} = @m
    init_radial_velocity(rpp, uinitradial)
    init_radial_velocity(rps, uinitradial)
  end
end
initialize:compile()

task simulate(rz_all : region(zone), rp_all : region(point),
              rs_all : region(side(wild, wild, wild, wild)),
              rm_all : region(mesh(rz_all, rp_all, rs_all)),
              conf : config)
  , reads(rz_all, rp_all, rs_all, rm_all)
  , writes(rz_all, rp_all, rs_all, rm_all)
  var alfa = conf.alfa
  var cfl = conf.cfl
  var cflv = conf.cflv
  var cstop = conf.cstop
  var dtfac = conf.dtfac
  var dtinit = conf.dtinit
  var dtmax = conf.dtmax
  var gamma = conf.qgamma
  var q1 = conf.q1
  var q2 = conf.q2
  var qgamma = conf.qgamma
  var ssmin = conf.ssmin
  var tstop = conf.tstop
  var uinitradial = conf.uinitradial
  var vfix = {x = 0.0, y = 0.0}

  var use_foreign = conf.use_foreign

  var interval = 10
  -- var start_time = get_abs_time()
  -- var last_time = start_time

  var time = 0.0
  var cycle = 0
  var dt = dtmax
  var dthydro = dtmax
  while cycle < cstop and time < tstop do
    dt = calc_global_dt(dt, dtfac, dtinit, dtmax, dthydro, time, tstop, cycle)

    if cycle > 0 and cycle % interval == 0 then
    --   var current_time = get_abs_time()
    --   print_simulation_loop(cycle, time, dt, start_time, last_time, current_time, interval)
    --   last_time = current_time
    end

    for m in rm_all do
      var {rz = rzp, rpp, rpg, rps, rs = rsp} = @m
      init_step_points(rpp)
      init_step_points(rps)
    end

    for m in rm_all do
      var {rz = rzp, rpp, rpg, rps, rs = rsp} = @m
      adv_pos_half(rpp, dt)
      adv_pos_half(rps, dt)
    end

    for m in rm_all do
      var {rz = rzp, rpp, rpg, rps, rs = rsp} = @m
      init_step_zones(rz, m.zstart, m.zend, use_foreign)
    end

    for m in rm_all do
      var {rz = rzp, rpp, rpg, rps, rs = rsp} = @m
      calc_centers(rz, rpp, rpg, rs, m.sstart, m.send, use_foreign)
    end

    for m in rm_all do
      var {rz = rzp, rpp, rpg, rps, rs = rsp} = @m
      calc_volumes(rz, rpp, rpg, rs, m.sstart, m.send, use_foreign)
    end

    for m in rm_all do
      var {rz = rzp, rpp, rpg, rps, rs = rsp} = @m
      calc_surface_vecs(rz, rpp, rpg, rs, m.sstart, m.send, use_foreign)
    end

    for m in rm_all do
      var {rz = rzp, rpp, rpg, rps, rs = rsp} = @m
      calc_edge_len(rz, rpp, rpg, rs, m.sstart, m.send, use_foreign)
    end

    for m in rm_all do
      var {rz = rzp, rpp, rpg, rps, rs = rsp} = @m
      calc_char_len(rz, rpp, rpg, rs, m.sstart, m.send, use_foreign)
    end

    for m in rm_all do
      var {rz = rzp, rpp, rpg, rps, rs = rsp} = @m
      calc_rho_half(rz, m.zstart, m.zend, use_foreign)
    end

    for m in rm_all do
      var {rz = rzp, rpp, rpg, rps, rs = rsp} = @m
      sum_point_mass(rz, rpp, rpg, rs, m.sstart, m.send, use_foreign)
    end

    for m in rm_all do
      var {rz = rzp, rpp, rpg, rps, rs = rsp} = @m
      calc_state_at_half(rz, gamma, ssmin, dt, m.zstart, m.zend, use_foreign)
    end

    for m in rm_all do
      var {rz = rzp, rpp, rpg, rps, rs = rsp} = @m
      calc_force_pgas(rz, rpp, rpg, rs, m.sstart, m.send, use_foreign)
    end

    for m in rm_all do
      var {rz = rzp, rpp, rpg, rps, rs = rsp} = @m
      calc_force_tts(rz, rpp, rpg, rs, alfa, ssmin, m.sstart, m.send, use_foreign)
    end

    for m in rm_all do
      var {rz = rzp, rpp, rpg, rps, rs = rsp} = @m
      calc_force_qcs(rz, rpp, rpg, rs, qgamma, q1, q2, m.zstart, m.zend, m.sstart, m.send, use_foreign)
    end

    for m in rm_all do
      var {rz = rzp, rpp, rpg, rps, rs = rsp} = @m
      sum_point_force(rz, rpp, rpg, rs, m.sstart, m.send, use_foreign)
    end

    for m in rm_all do
      var {rz = rzp, rpp, rpg, rps, rs = rsp} = @m
      apply_boundary_conditions(rpp)
      apply_boundary_conditions(rps)
    end

    for m in rm_all do
      var {rz = rzp, rpp, rpg, rps, rs = rsp} = @m
      calc_accel(rpp)
      calc_accel(rps)
    end

    for m in rm_all do
      var {rz = rzp, rpp, rpg, rps, rs = rsp} = @m
      adv_pos_full(rpp, dt)
      adv_pos_full(rps, dt)
    end

    for m in rm_all do
      var {rz = rzp, rpp, rpg, rps, rs = rsp} = @m
      calc_centers_full(rz, rpp, rpg, rs, m.sstart, m.send, use_foreign)
    end

    for m in rm_all do
      var {rz = rzp, rpp, rpg, rps, rs = rsp} = @m
      calc_volumes_full(rz, rpp, rpg, rs, m.sstart, m.send, use_foreign)
    end

    for m in rm_all do
      var {rz = rzp, rpp, rpg, rps, rs = rsp} = @m
      calc_work(rz, rpp, rpg, rs, dt, m.sstart, m.send, use_foreign)
    end

    for m in rm_all do
      var {rz = rzp, rpp, rpg, rps, rs = rsp} = @m
      calc_work_rate(rz, dt)
    end

    for m in rm_all do
      var {rz = rzp, rpp, rpg, rps, rs = rsp} = @m
      calc_energy(rz)
    end

    for m in rm_all do
      var {rz = rzp, rpp, rpg, rps, rs = rsp} = @m
      calc_rho_full(rz)
    end

    dthydro = dtmax
    for m in rm_all do
      var {rz = rzp, rpp, rpg, rps, rs = rsp} = @m
      dthydro = min(dthydro, calc_dt_hydro(rz, dt, dtmax, cfl, cflv))
    end

    cycle += 1
    time += dt
  end
end
simulate:compile()

task all_zones_coloring(rz_all : region(zone), rp_all : region(point),
                        rs_all : region(side(wild, wild, wild, wild)),
                        rm_all : region(mesh(rz_all, rp_all, rs_all)),
                        conf : config)
  : c.legion_coloring_t -- coloring(rz_all)
  , reads(rm_all.{zstart, zend})
  return [c.legion_coloring_create]() -- return foreign_all_zones_coloring(conf, rm_all)
end
all_zones_coloring:compile()

-- task all_points_coloring(rp_all : region(point),
--                          pcolor_is : ispace(int), pcolor_a : array(pcolor_is, int),
--                          conf : config)
--   : int -- coloring(rp_all)
--   , reads(pcolor_a)
--   return 0 -- return foreign_all_points_coloring(conf, pcolor_a)
-- end
-- all_points_coloring:compile()

-- task private_points_coloring(rp_all_private : region(point),
--                              pcolor_is : ispace(int), pcolor_a : array(pcolor_is, int),
--                              conf : config)
--   : int -- coloring(rp_all_private)
--   , reads(pcolor_a)
--   return 0 -- return foreign_private_points_coloring(conf, pcolor_a)
-- end
-- private_points_coloring:compile()

-- task ghost_points_coloring(rp_all_ghost : region(point),
--                            pcolor_is : ispace(int), pcolor_a : array(pcolor_is, int),
--                            pcolors_is : ispace(int), pcolors_a : array(pcolors_is, uint64),
--                            conf : config)
--   : int -- coloring(rp_all_ghost)
--   , reads(pcolor_a, pcolors_a)
--   return 0 -- return foreign_ghost_points_coloring(conf, pcolor_a, pcolors_a)
-- end
-- ghost_points_coloring:compile()

-- task shared_points_coloring(rp_all_shared : region(point),
--                             pcolor_shared_is : ispace(int), pcolor_shared_a : array(pcolor_shared_is, int),
--                             conf : config)
--   : int -- coloring(rp_all_shared)
--   , reads(pcolor_shared_a)
--   return 0 -- return foreign_shared_points_coloring(conf, pcolor_shared_a)
-- end
-- shared_points_coloring:compile()

task all_sides_coloring(rz_all : region(zone), rp_all : region(point),
                        rs_all : region(side(wild, wild, wild, wild)),
                        rm_all : region(mesh(rz_all, rp_all, rs_all)),
                        conf : config)
  : c.legion_coloring_t -- coloring(rs_all)
  , reads(rm_all.{sstart, send})
  return [c.legion_coloring_create]() -- return foreign_all_sides_coloring(conf, rm_all)
end
all_sides_coloring:compile()

-- task read_input(conf : config,
--                 rz_all : region(zone), rp_all : region(point), rs_all : region(side(wild, wild, wild, wild)),
--                 rm_all : region(mesh(rz_all, rp_all, rs_all)),
--                 pcolor_is : ispace(int), pcolor_a : array(pcolor_is, int),
--                 pcolors_is : ispace(int), pcolors_a : array(pcolors_is, uint64),
--                 pcolor_shared_is : ispace(int), pcolor_shared_a : array(pcolor_shared_is, int))
--   , reads(rz_all, rp_all, rs_all, rm_all, pcolor_a, pcolors_a, pcolor_shared_a)
--   , writes(rz_all, rp_all, rs_all, rm_all, pcolor_a, pcolors_a, pcolor_shared_a)
--   foreign_read_input(conf, rz_all, rp_all, rs_all, rm_all, pcolor_a, pcolors_a, pcolor_shared_a)
-- end
-- read_input:compile()

task validate_output(conf : config,
                     rz_all : region(zone), rp_all : region(point), rs_all : region(side(wild, wild, wild, wild)))
  , reads(rz_all, rp_all, rs_all)
  -- foreign_validate_output(conf, rz_all, rp_all, rs_all)
end
validate_output:compile()

task test()
  var conf : config -- = read_config()

  var rz_all = region(zone, conf.nz)
  var rp_all = region(point, conf.np)
  var rs_all = region(side(wild, wild, wild, wild), conf.ns)
  var rm_all = region(mesh(rz_all, rp_all, rs_all), conf.npieces)

  -- Create temporary arrays for pointers to use while building the
  -- regions.

  -- -- Array for tracking number of colors per point:
  -- var pcolor_is = ispace(int)(conf.np)
  -- var pcolor_a = array(pcolor_is, int)()

  -- -- Bitmask for colors of ghost points:
  -- var bits = 64                                -- must match bitmask type
  -- var words = (conf.npieces + bits - 1)/bits
  -- var pcolors_is = ispace(int)(conf.np*words)
  -- var pcolors_a = array(pcolors_is, uint64)()   -- must match bits

  -- -- Array for colors of disjoint partition of shared points:
  -- var pcolor_shared_is = ispace(int)(conf.np)
  -- var pcolor_shared_a = array(pcolor_shared_is, int)()

  -- -- Read simulation data into regions.
  -- read_input(conf, rz_all, rp_all, rs_all, rm_all, pcolor_is, pcolor_a, pcolors_is, pcolors_a, pcolor_shared_is, pcolor_shared_a)

  -- Partition zones into disjoint pieces.
  var rz_all_c = all_zones_coloring(rz_all, rp_all, rs_all, rm_all, conf)
  var rz_all_p = partition(disjoint, rz_all, rz_all_c)

  -- Partition points into private and ghost regions.
  var rp_all_c : c.legion_coloring_t -- all_points_coloring(rp_all, pcolor_is, pcolor_a, conf)
  var rp_all_p = partition(disjoint, rp_all, rp_all_c)
  var rp_all_private = rp_all_p[0]
  var rp_all_ghost = rp_all_p[1]

  -- Partition private points into disjoint pieces by zone.
  var rp_all_private_c : c.legion_coloring_t -- private_points_coloring(rp_all_private, pcolor_is, pcolor_a, conf)
  var rp_all_private_p = partition(disjoint, rp_all_private, rp_all_private_c)

  -- Partition ghost points into aliased pieces by zone.
  var rp_all_ghost_c : c.legion_coloring_t -- ghost_points_coloring(rp_all_ghost, pcolor_is, pcolor_a, pcolors_is, pcolors_a, conf)
  var rp_all_ghost_p = partition(aliased, rp_all_ghost, rp_all_ghost_c)

  -- Partition ghost points into disjoint pieces, breaking ties
  -- between zones so that each point goes into one region only.
  var rp_all_shared_c : c.legion_coloring_t -- shared_points_coloring(rp_all_ghost, pcolor_shared_is, pcolor_shared_a, conf)
  var rp_all_shared_p = partition(disjoint, rp_all_ghost, rp_all_shared_c)

  -- Partition sides into disjoint pieces by zone.
  var rs_all_c = all_sides_coloring(rz_all, rp_all, rs_all, rm_all, conf)
  var rs_all_p = partition(disjoint, rs_all, rs_all_c)

  -- Stuff regions into mesh pieces.
  for m in rm_all do
    var zones = rz_all_p[0 --[[m.mcolor]]]
    var private = rp_all_private_p[0 --[[m.mcolor]]]
    var ghost = rp_all_ghost_p[0 --[[m.mcolor]]]
    var shared = rp_all_shared_p[0 --[[m.mcolor]]]
    var sides = rs_all_p[0 --[[m.mcolor]]]

    @m = [ mesh(rz_all, rp_all, rs_all) ]({
      rzp = zones,
      rpp = private,
      rpg = ghost,
      rps = shared,
      rsp = sides,
      mcolor = m.mcolor,
      zstart = m.zstart,
      zend = m.zend,
      sstart = m.sstart,
      send = m.send
    })
  end

  initialize(rz_all, rp_all, rs_all, rm_all, conf)

  -- print_simulation_start()
  -- var start_time = get_abs_time()
  simulate(rz_all, rp_all, rs_all, rm_all, conf)
  -- var stop_time = get_abs_time()
  -- print_global_elapsed_time(start_time, stop_time)

  -- write_output(conf, rz_all, rp_all, rs_all)
  validate_output(conf, rz_all, rp_all, rs_all)
end
test:compile()

task toplevel()
  test()
end
toplevel:compile()
